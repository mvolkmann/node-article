<!DOCTYPE html>
<html>
  <head>
    <meta name="description" content="Web App Step-By-Step">
    <meta name="keywords" content="SETT, OCI, JavaScript, Node.js, React, PostgreSQL">
    <meta name="author" content="R. Mark Volkmann">
    <title>SETT ? 2017 - Web App Step-By-Step</title>

    <link rel="alternate" type="application/rss+xml" title="RSS" href="http://ociweb.com/sett/rss.xml">
    <link rel="stylesheet" href="styles/SETT.css">
    <link rel="stylesheet" href="styles.css">

    <style>
      code {
        font-family: "Consolas", "Bitstream Vera Sans Mono", "Courier New", Courier, monospace !important;
      }
      img {
        border: solid lightgray 2px;
        margin-top: 10px;
        padding: 5px;
        width: 600px;
      }
    </style>

    <link rel="stylesheet" href="syntaxhighlighter/dist/theme.css">
    <script src="syntaxhighlighter/dist/syntaxhighlighter.js"></script>
  </head>
  <body>
    <!--#include virtual="header.shtml" -->

    <h1>Web App, Step By Step</h1>

    <p class="author">
      by<br/>
      R. Mark Volkmann
      <br/>Object Computing, Inc. (OCI)
    </p>

    <h3>Introduction</h3>
    <p>
      Many people talk about how easy it is
      to build web applications using Node.js.
      However, it's difficult to find resources that walk though all the steps.
      We will do that here.
      Some details will be omitted.
      We want to focus on the primary steps.
    </p>
    <p>
      This article makes specific technology/tool choices.
      Obviously the steps differ if different choices are made.
      The primary choices made here include Node.js, PostgreSQL, and React.
      This article was inspired by the Frontend Masters workshop
      "Zero to Production Node.js on Amazon Web Services" by Kevin Whinnery
      where he made different tooling choices.
    </p>
    <p>
      We will cover many topics including these:
    </p>
    <ul>
      <li>Node.js</li>
      <li>npm</li>
      <li>Express</li>
      <li>HTTPS</li>
      <li>PostgreSQL</li>
      <li>REST services</li>
      <li>authentication with encrypted tokens</li>
      <li>CORS</li>
      <li>socket.io for server to client communication</li>
      <li>creating SSL certificates</li>
      <li>React and create-react-app</li>
      <li>nodemon</li>
      <li>Docker</li>
    </ul>
    <p>
      The example application presented in this article is avaiable at
      <a href="https://github.com/mvolkmann/ice-cream-app" target="_blank">https://github.com/mvolkmann/ice-cream-app</a>.
    </p>
    <p>
      You will absorb more from this article if you run all the commands
      and download/create all the files as we walk through the process.
      If you are working on a Windows machine,
      most of the steps will be performed in a Command Prompt window.
      If you are working on a Mac or Linux machine,
      most of the steps will be performed in a Terminal window.
      Throughout the remainder of this article
      we'll refer to both as simply a "terminal".
    </p>
    <p>
      Ask Zach Klein to write a similar article using Grails.
      What security and scaling issues does Grails address that you haven't?
    </p>

    <h3>Node.js</h3>
    <p>
      Node can be used to develop many kinds of applications including
      command-line apps, web apps (HTTP/HTTPS servers), and desktop apps (see
      <a href="http://electron.atom.io/" target="_blank">http://electron.atom.io/</a>).
      The main Node.js website is at
      <a href="https://nodejs.org/" target="_blank">https://nodejs.org/</a>.
      It contains this excellent summary:
    </p>
    <blockquote>
      "Node.js is a JavaScript runtime built on Chrome's V8 JavaScript engine.
      Node.js uses an event-driven, non-blocking I/O model
      that makes it lightweight and efficient."
    </blockquote>
    <p>
      The "DOCS" link at the top of this page contains excellent documentation.
      Refer to this later when reading through the implementation
      of our REST services.
    </p>
    <p>
      Press the large green button that says "Current"
      to download the current version of Node.js.
      Double-click the file that is downloaded to run the installer.
      After the install completes, open a terminal and
      the enter the following to verify that it worked:
    </p>
    <pre class="brush: js">
node -v</pre>
    <p>
      Installing Node also installs npm which is the "Node Package Manager"
      (despite claims to the contrary).  npm makes it easy to install
      code libraries (a.k.a. packages) from the npm repository.
      To discover the available packages, browse
      <a href="https://www.npmjs.com/" target="_blank">https://www.npmjs.com/</a>.
      As of the date of this article the npm repository
      hosts over 350,000 packages.
    </p>
    <p>
      Node applications typically have a file named <code>package.json</code>
      that describes the app, including the packages on which it depends.
      To create a <code>package.json</code> file for a new app,
      enter <code>npm init</code>.
      To install a dependency for an app
      and record it in <code>package.json</code>,
      enter <code>npm install -S <i>package</i></code>.
      For dependencies related to development tasks that are not needed
      when the app runs, use the <code>-D</code> option
      instead of <code>-S</code>.
    </p>
    <p>
      Here are the steps to build and run a "Hello World" command-line app.
      It uses a library called chalk
      (<a href="https://www.npmjs.com/package/chalk" target="_blank">https://www.npmjs.com/package/chalk</a>)
      in order to demonstrate use of npm packages.
    </p>
    <ol>
      <li>Create a directory for the app and cd to it.</li>
      <li>Run <code>npm init</code> to create <code>package.json</code>.
        This will ask several questions.
        It is okay to accept all the defaults.</li>
      <li>Create the file <code>index.js</code> and enter the following code:
        <pre class="brush: js">
const chalk = require('chalk');
const name = process.argv[2];
console.log('Hello, ' + chalk.red.bold(name) + '!');</pre>
        <p>
          <code>process.argv</code> holds command-line arguments.
          The first value is the path to the node executable.
          The second value is the path to the file being executed.
          The third value (at index 2) is the first command-line argument.
        </p>
      </li>
      <li>To run this, enter <code>node index.js <i>your-name</i></code></li>
    </ol>
    <p>
      A server is a program that listens for requests and produces responses.
      The most common kind is an HTTP server that uses
      request and repsonse messages with a specific format.
      It can process requests for files and
      process requests to perform specific operations.
      Often processing involves interacting with a database
      to perform CRUD operations.
      CRUD stands for "Create Retrieve Update Delete" which are
      the most common things one does with data.
    </p>
    <p>
      Here is a simple example of a Node HTTP server that
      serves files from a directory named "public"
      and responds to requests for the current year.
      It uses the Express package which is a
      "fast, unopinionated, minimalist web framework for Node".
      For more information, see
      <a href="https://github.com/expressjs/express" target="_blank">https://github.com/expressjs/express</a>.
      To install it, enter the following from your app directory: <code>npm install express</code>
    </p>
    <p>
      Place the following code in a file named <code>server.js</code>:
    </p>
    <pre class="brush: js">
const express = require('express');
const app = express();

app.use(express.static(__dirname + '/public'));

app.get('/year', (request, response) => {
  // request is an object that contains detail
  // about the request that was received.
  // response is an object that contains methods
  // for populating the response to be sent.
  // These are often abbreviated as "req" and "res"
  // as you'll see in later code.
  response.send(new Date().getFullYear().toString());
});

const PORT = 1919;
app.listen(PORT, () => {
  console.log('listenting on ' + PORT);
});</pre>
    <p>
      To run this, enter <code>node server.js</code>
      and browse <code>localhost:1919/year</code>.
    </p>
    <p>
      To demonstrate serving files, follow these steps:
    </p>
    <ol>
      <li>Create a subdirectory named <code>public</code>.</li>
      <li>Create a file named <code>demo.html</code> in that directory.</li>
      <li>Add HTML to that file such as:
        <pre>&lt;h1>Serving files works!&lt;/h1></pre>
      </li>
      <li>Browse <code>localhost:1919/demo.html.</code></li>
    </ol>

    <h3>Database</h3>
    <p>
      The sample application uses the relational database
      <a href="https://www.postgresql.org/" target="_blank">PostgreSQL</a>.
      It is a very popular, open source database.
      <a href="https://en.wikipedia.org/wiki/NoSQL" target="_blank">NoSQL</a>
      databases are another excellent choice.
      <a href="https://www.mongodb.com/" target="_blank">MongoDB</a>
      is a NoSQL database that is popular in the Node community.
    </p>

    <p>
      For help with PostgreSQL see
      <a href="https://www.postgresql.org/docs/9.6/static/index.html" target="_blank">https://www.postgresql.org/docs/9.6/static/index.html</a>.
    </p>
    <p>
      For help on using the PostgreSQL psql command see
      <a href="http://postgresguide.com/utilities/psql.html" target="_blank">http://postgresguide.com/utilities/psql.html</a>.
    </p>
    <p>
      For help with pg, an npm package for iteracting with PostgreSQL databases, see
      <a href="https://github.com/brianc/node-postgres" target="_blank">https://github.com/brianc/node-postgres</a> and
      <a href="https://github.com/brianc/node-postgres/wiki" target="_blank">https://github.com/brianc/node-postgres/wiki</a>.
    </p>
    <p>
      To install PostgreSQL in macOS:
    </p>
    <ol>
      <li>
        Install Homebrew by following the instructions at
        <a href="http://brew.sh/" target="_blank">http://brew.sh/</a>.
      </li>
      <li>
        Enter the following: <code>brew install postgresql</code>
      </li>
    </ol>
    <p>
      To install PostgreSQL in Windows:
    </p>
    <ol>
      <li>
        TODO: Get these steps.
      </li>
    </ol>

    <p>
      To start the database server, enter:
      <code>pg_ctl -D /usr/local/var/postgres start</code>
    </p>
    <p>
      To stop the database server later, enter:
      <code>pg_ctl -D /usr/local/var/postgres stop -m fast</code>
    </p>

    <p>
      We'll create three tables, <code>ice_cream</code>,
      <code>users</code>, and a table for mapping users to
      ice flavors named <code>user_ice_creams</code>.
      We'll also enable the <code>pgcrypo</code> extension
      so passwords can be encryped.
      Here is the Data Definition Language (DDL)
      for creating these tables:
    </p>
    <pre class="brush: js">
create extension pgcrypto; -- needed to encrypt passwords

create table ice_creams (
  id serial primary key,
  flavor varchar(50)
);

create table users (
  username varchar(50) primary key,
  password varchar(60) -- encrypted length
);

create table user_ice_creams (
  username varchar(50) references users (username),
  ice_cream_id integer references ice_creams (id)
);</pre>

    <p>
      Create a script that will be used to create the database,
      and recreate it to get a fresh start during testing.
    </p>
    <ol>
      <li>Create the file by entering: <code>touch recreatedb</code></li>
      <li>Edit the file <code>recreatedb</code> and add the following lines:
        <pre class="brush: js">
db=ice_cream
dropdb $db
createdb $db
psql $db -f tables.ddl</pre>
      </li>
      <li>Make this file executable by entering: <code>chmod a+x recreatedb</code></li>
      <li>Execute this file by entering: <code>./recreatedb</code></li>
    </ol>
    <p>
      Explore the newly created database with the following commands:<br>
    </p>
    <ol>
      <li>To list the existing databases: <code>psql -l</code><br></li>
      <li>To enter interactive mode for the ice_cream database: <code>psql -d ice_cream</code></li>
      <li>To list the tables in the current database: <code>\d</code></li>
      <li>To get information about the columns in the ice_creams table: <code>\d ice_creams</code></li>
      <li>To get all the rows in the ice_creams table: <code>select * from ice_creams;</code><br>
        Of course there is nothing to see yet, but try this again after our code adds data.
      </li>
      <li>To exit interactive mode, press ctrl-d.</li>
    </ol>

    <h3>Node and PostgreSQL</h3>
    <p>
      Server connections to the database use the "root" role by default
      and expect that it has superuser privilege.
      This role doesn't exist by default.  To create it:
    </p>
    <pre>
      createrole -s root</pre>

    <p>
      Many projects use Object/Relational Mapping (ORM) libraries
      to interact with relational databases rather than writing SQL.
      We forego that option here because SQL is a fairly universal skill
      and it is not hard to learn or use.
    </p>
    <p>
      To interact with our PostgreSQL database from Node code
      we will use the npm package
      <a href="https://github.com/brianc/node-postgres" target="_blank">pg</a>.
      More specifically, we will use a set of functions provided by the npm package
      <a href="https://www.npmjs.com/package/postgresql-easy" target="_blank">postgresql-easy</a>
      that, as the name implies, makes using the pg package even easier.
      Full disclosure, I created postgresql-easy while working on this article.
      Check it out!  The code is fairly short and easy to read.
    </p>
    <p>
      Another similar npm package to consider is
      <a href="https://github.com/vitaly-t/pg-promise" target="_blank">pg-promise</a>,
      which is provides a promise-based API.
      The next code example uses JavaScript promises.
      Understanding JavaScript promises is essential to following the code here.
      If you aren't yet familiar with those, you can find what you need to know at
      <a href="https://davidwalsh.name/promises" target="_blank">https://davidwalsh.name/promises</a>.
    </p>
    <p>
      Here is an example of perform some common operations on our database.
    </p>
    <pre class="brush: js">
const PgConnection = require('postgresql-easy');

const tableName = 'ice_creams';
const flavors = ['vanilla', 'chocolate', 'strawberry'];
let ids;

// Configure a connection to the database.
const pg = new PgConnection({
  database: 'ice_cream'
});

// Delete all rows from the ice_cream table.
pg.deleteAll(tableName)
  // Insert three new rows corresponding to vanilla, chocolate, and strawberry.
  .then(() => Promise.all(
    flavors.map(f => pg.insert(tableName, {flavor: f}))
  ))
  // Get an array of the ids of the new rows.
  .then(results => {
    ids = results.map(result => result.rows[0].id);
    console.log('inserted records with ids', ids);
  })
  // Delete the first row (vanilla).
  .then(() => pg.deleteById(tableName, ids[0]))
  // Change the flavor of the second row (chocolate) to "chocolate chip".
  .then(() => pg.updateById(tableName, ids[1], {flavor: 'chocolate chip'}))
  // Get all the rows in the table.
  .then(() => pg.getAll(tableName))
  // Output their id and flavor.
  .then(result => {
    for (const row of result.rows) {
      console.log(row.id, row.flavor);
    }
  })
  // Disconnect from the database.
  .then(() => pg.disconnect())
  // Catch and report any errors that occur in the previous steps.
  .catch(err => {
    throw err;
  });</pre>

    <h3>REST Services</h3>
    <p>
      Now that we have code for interacting with the database,
      we can implement services to do this
      that can be invoked from the browser.
    </p>
    <p>
      REST stands for "REpresentational State Transfer".
      To dig deeper into it, see
      <a href="https://en.wikipedia.org/wiki/Representational_state_transfer" target="_blank">this</a>
      Wikipedia page.
      All you need to know for now is that REST services typically
      use the HTTP/HTTPS protocol for request and response messages,
      act on "resources", use carefully selected URLs to identify resources,
      and map HTTP verbs to CRUD operations.
      The mapping is as follows:
    </p>
    <ul>
      <li>POST -> Create</li>
      <li>GET -> Retrieve</li>
      <li>PUT -> Update</li>
      <li>DELETE -> Delete</li>
      <li>POST -> everything else</li>
    </ul>
    <p>
      There is an exception where PUT an be used to create a resource.
      Also, PATCH can be used for a partial update.
    </p>
    <p>
      We will implement the REST services using the npm package Express
      which was described earlier.
    </p>
    <p>
      These services require authentication.
      Note how each checks for this with a call to auth.authorize
      and returns if that returns false.
      At first glance this may seem like a large amount of code.
      However, I think you'll agree that each piece is fairly small and simple.
    </p>
    <pre class="brush: js">
const auth = require('node-token-auth');
const express = require('express');
const PgConnection = require('postgresql-easy');
const server = require('./server');

// Configure the algorithm and password used to encrypt auth tokens
// and set the session timeout in minutes.
auth.configure('aes-256-ctr', 'V01kmann', 1);

const app = express();
server.setup(app);

function handleError(res, err) {
  res.statusMessage = `${err.toString()}; ${err.detail}`;
  res.status(500).send();
}

const pg = new PgConnection({
  database: 'ice_cream' // defaults to username
  //host: 'localhost', // default
  //idleTimeoutMillis: 30000, // before a client is closed (default is 30000)
  //max: 10, // max clients in pool (default is 10)
  //password: '', // not needed in this example
  //port: 5432, // the default
  //user: '' // not needed in this example
});

/**
 * Deletes an ice cream flavor from a given user.
 */
app.delete('/ice-cream/:username/:id', (req, res) => {
  if (!auth.authorize(req, res)) return;

  const {id, username} = req.params;

  const sql =
    'delete from user_ice_creams ' +
    'where username=$1 and ice_cream_id=$2';
  pg.query(sql, username, id)
    .then(() => res.send())
    .catch(handleError.bind(null, res));
});

/**
 * Retrieves all records from the ice-cream table.
 */
app.get('/ice-cream/:username', (req, res) => {
  if (!auth.authorize(req, res)) return;

  const username = req.params.username;
  const sql =
    'select ic.id, ic.flavor ' +
    'from ice_creams ic, user_ice_creams uic ' +
    `where uic.username='${username}' ` +
    'and uic.ice_cream_id=ic.id';
  pg.query(sql)
    .then(result => {
      res.json(result.rows);
    })
    .catch(handleError.bind(null, res));
});

/**
 * Adds an ice cream flavor for a given user,
 * creating a new record in the ice-cream table.
 */
app.post('/ice-cream/:username', (req, res) => {
  if (!auth.authorize(req, res)) return;

  const {username} = req.params;
  const {flavor} = req.query;

  function associate(username, iceCreamId) {
    const sql =
      'insert into user_ice_creams (username, ice_cream_id) ' +
      'values ($1, $2)';
    pg.query(sql, username, iceCreamId)
      .then(() => res.send(String(iceCreamId)))
      .catch(handleError.bind(null, res));
  }

  // Get the id of the flavor if it already exists.
  let sql = 'select id from ice_creams where flavor=$1';
  pg.query(sql, flavor)
    .then(result => {
      const [row] = result.rows;
      if (row) {
        const {id} = row;
        associate(username, id);
      } else {
        // The flavor doesn't exist, so create it.
        sql = 'insert into ice_creams (flavor) values ($1) returning id';
        pg.query(sql, flavor)
          .then(result => {
            const [row] = result.rows;
            if (row) {
              const {id} = row;
              associate(username, id);
            } else {
              handleError(res, 'failed to create new flavor');
            }
          })
          .catch(handleError.bind(null, res));
      }
    })
    .catch(handleError.bind(null, res));
});

/**
 * Updates a record in the ice-cream table by id.
 */
app.put('/ice-cream/:id', (req, res) => {
  if (!auth.authorize(req, res)) return;

  const {id} = req.params;
  const {flavor} = req.query;
  pg.updateById('ice_creams', id, {flavor})
    .then(() => res.send())
    .catch(handleError.bind(null, res));
});

/**
 * Logs in a user.
 * curl -k -XPOST https://localhost/login ...
 * The username and password must be in the body
 * and the content type must be "application/json".
 */
app.post('/login', (req, res) => {
  const {username, password} = req.body;
  if (!username) {
    res.statusMessage = 'Missing Username';
    return res.status(400).send();
  }
  if (!password) {
    res.statusMessage = 'Missing Password';
    return res.status(400).send();
  }

  auth.generateToken(username, req, res);

  const sql =
    `select password = crypt('${password}', password) as authenticated ` +
    `from users where username='${username}'`;
  pg.query(sql)
    .then(result => {
      const [row] = result.rows;
      if (row) {
        res.send(row.authenticated);
      } else {
        res.statusMessage = 'Username Not Found';
        res.status(404).send();
      }
    })
    .catch(handleError.bind(null, res));
});

/**
 * Logs out a user.
 * curl -k -XPOST https://localhost/logout ...
 * The "Authorization" request header must be set.
 */
app.post('/logout', (req, res) => {
  if (!auth.authorize(req, res)) return;

  auth.deleteToken(req);
  res.send();
});

/**
 * Signs up a new user.
 * curl -k -XPOST https://localhost/signup ...
 * The username and password must be in the body
 * and the content type must be "application/json".
 */
app.post('/signup', (req, res) => {
  const {username, password} = req.body;
  if (!username) {
    res.statusMessage = 'Missing Username';
    return res.status(400).send();
  }
  if (!password) {
    res.statusMessage = 'Missing Password';
    return res.status(400).send();
  }

  auth.generateToken(username, req, res);

  // Encrypt password using a Blowfish-based ciper (bf)
  // performing 8 iterations.
  const sql =
    'insert into users (username, password) ' +
    `values('${username}', crypt('${password}', gen_salt('bf', 8)))`;

  pg.query(sql)
    .then(() => res.send())
    .catch(handleError.bind(null, res));
});

server.start();</pre>

    <p>
      What about that "server" part we conveniently skipped over?
      When the server is handling both the REST services and
      the files that will be served to the browser
      (such as <code>.html</code>, <code>.css</code>, and
      <code>.js</code> files), it can be very simple.
      However, if a separate server is used to serve those files
      then CORS must be configured to allow code in the browser
      to invoke the REST services.
    </p>

    <p>
      CORS stands for "Cross-Origin Resource Sharing".
      It is needed to allow the client-side of a web app to retrieve resources
      (including REST service responses) that are hosted at a different domain
      than the client-side resource
      (such as HTML, CSS, JavaScript, and media files).
      A standard security feature in browsers prevents
      code downloaded from one domain from sending requests
      to another domain.  CORS can selectively enable this.
      To learn more about CORS, see
      <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS" target="_blank">this</a>
      page on the Mozilla Developer Network.
      For now all you need to know is that the REST server needs to
      include certain headers in the responses it produces
      to enable this.
    </p>
    <p>
      Another feature our server configures
      is the use of HTTPS instead of HTTP.
      This uses Transport Layer Security (TLS) to
      decrypt requests and encrypt responses.
    </p>
    <p>
      Here is the code in <code>server.js</code>
      that configures both CORS and HTTPS:
    </p>
    <pre class="brush: js">
const bodyParser = require('body-parser');
const fs = require('fs');
const https = require('https');
const sio = require('socket.io');

let server;

function setup(app) {
  // Suppress the x-powered-by response header
  // so hackers don't get a clue that might help them.
  app.set('x-powered-by', false);

  // Enable use of CORS.
  app.use((req, res, next) => {
    res.header('Access-Control-Allow-Origin', '*');
    res.header('Access-Control-Allow-Headers',
      'Accept, Authorization, Content-Type, Origin, X-Requested-With');
    res.header('Access-Control-Expose-Headers',
      'Authorization, Content-Type');
    res.header('Access-Control-Allow-Methods', 'GET,DELETE,POST,PUT');
    next();
  });

  app.use(bodyParser.json({extended: true}));

  const options = {
    key: fs.readFileSync('key.pem'),
    cert: fs.readFileSync('cert.pem'),
    passphrase: 'icecream'
  };
  server = https.createServer(options, app);
  server.on('error', err => {
    console.error(err.code === 'EACCES' ? 'must use sudo' : err);
  });
}

function start() {
  const PORT = 443;
  server.listen(PORT, () => console.log('listening on port', PORT));

  const io = sio.listen(server);
  io.on('connection', socket => global.socket = socket);
}

module.exports = {setup, start};</pre>

    <h3>YOU NEED A GOOD ERROR MESSAGE FROM THE SERVER WHEN IT CANNOT CONNECT TO THE DATABASE!</h3>

    <h3>Authentication and Authorization</h3>
    <p>
      We want to require users to register for an account before using the app.
      They do this by supplying a username and password of their choosing,
      after which they are automatically logged in.
      Login is required for all subsequent sessions.
    </p>
    <p>
      Both registering a new account and logging in to an existing account
      result in an authentication token being returned to the browser.
      The client-side code must include this token in all REST calls.
      This is supported by the npm package <code>node-token-auth</code> at
      <a href="https://www.npmjs.com/package/node-token-auth" target="_blank">https://www.npmjs.com/package/node-token-auth</a>
      The content of the encrypted tokens it creates is explained there.
      I created <code>node-token-auth</code> for this article.  Check it out!
    </p>
    <p>
      Another popular authentication option for Node is Passport at
      <a href="http://passportjs.org/" target="_blank">http://passportjs.org/</a>.
    </p>

    <h3>Create a self-signed certificate</h3>
    <p>
      We want to used HTTPS for the website rather than HTTP
      for security reasons.  This requires an SSL certificate.
      For a real website this can be done for free using
      <a href="https://letsencrypt.org/" target="_blank">https://letsencrypt.org/</a>.
      For testing purposes, an easier approach is to use openssl as follows:
    </p>
    <pre>
$ openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365
Generating a 4096 bit RSA private key
.................................++
.................................++
writing new private key to 'key.pem'
Enter PEM pass phrase:
Verifying - Enter PEM pass phrase:
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [AU]:{your-country-code}
State or Province Name (full name) [Some-State]:{your-state}
Locality Name (eg, city) []:{your-city}
Organization Name (eg, company) [Internet Widgits Pty Ltd]:{your-company}
Organizational Unit Name (eg, section) []:{your-division}
Common Name (e.g. server FQDN or YOUR name) []:{your-name}
Email Address []:{your-email}</pre>
    <p>
      This creates the files <code>cert.pem</code> and <code>key.pem</code>
      in the current directory.
    </p>
    <p>Is the -w option needed to allow entering an SSL passphrase?</p>
    <p>
      The standard port to use with SSL is 443.
      Since this is a protected port, the server must be started with sudo.
      Otherwise the following error message will be output:
      Error: listen EACCES 0.0.0.0:443
    </p>
    <p>
      If the passphrase is wrong, the following error will be reported:
    </p>
    <pre>
      Error: error:06065064:digital envelope routines:EVP_DecryptFinal_ex:bad decrypt</pre>

    <p>
      When the protocol is https and default port (443) is used,
      it does not need to be specified in URLs.
    </p>
    <p>
      The curl command can be used test REST services like this:
    </p>
    <pre>
      curl -k https://localhost/{route}</pre>
    <p>
      The <code>-k</code> (or <code>--insecure</code>) option
      allows connections to SSL sites without certificates.
      This is useful when testing using self-signed certificates.
    </p>

    <h3>Running the Sample App</h3>
    <p>
      In the next section we will discuss the implementation of a web UI.
      It will aid your understanding to install and run the app now.
      Here are the steps to do that:
    </p>
    <ol>
      <li>Open a terminal.</li>
      <li>
        Start the database daemon with:<br>
        <code>pg_ctl -D /usr/local/var/postgres start</code>
      </li>
      <li>cd to the directory where you'd like to install the project.</li>
      <li>git clone https://github.com/mvolkmann/ice-cream-app.git</li>
      <li>Enter: <code>cd ice-cream-app/server</code></li>
      <li>
        Enter: <code>npm install</code><br>
        This installs all the dependencies found in
        <code>ice-cream-app/server/package.json</code>.
      </li>
      <li>
        Start the REST server by entering: <code>npm start</code><br>
        Another way to start the REST server is to use nodemon
        which is described <a href="#nodemon">later</a>.
      </li>
      <li>Enter: <code>cd ..</code></li>
      <li>
        Enter: <code>npm install</code><br>
        This installs all the dependencies found in
        <code>ice-cream-app/package.json</code>.
      </li>
      <li>
        Configure the use HTTPS by the web server (instead of HTTP) by entering:
        <code>export HTTPS=true</code>
      </li>
      <li>
        Start the web server by entering: <code>npm start</code></li>
      <li>
        Tell browser to always trust the self-signed certificate by
        browsing https://localhost.
      </li>
      <li>
        <p>
          In Chrome, click "ADVANCED" and then "Proceed to localhost (unsafe)".
        </p>
        <p>
          In Firefox, press the "Advanced" button,
          press the "Add Exception..." button,
          and press the "Confirm Security Exception" button.
        </p>
        <p>
          In Safari, press "Show Certificate" button.
          In "When using this certificate" dropdown, select "Always Trust".
          Press "Continue" button.
          Enter your password to confirm this action.
        </p>
      </li>
      <li>
        Browse https://localhost:3000<br>
        Do you need to enable HTTPS again here?
     </li>
    </ol>

    <h3>create-react-app</h3>
    <p>
      The easiest way to get started with a new React web app
      is to use create-react-app at
      <a href="https://github.com/facebookincubator/create-react-app" target="_blank">https://github.com/facebookincubator/create-react-app</a>.
    </p>
    <ol>
      <li>To install create-react-app: <code>npm install -g create-react-app</code></li>
      <li>
        To create our web application: <code>create-react-app ice-cream-app</code><br>
        Depending on your computer, this will take around one minute.
      </li>
      <li><code>cd ice-cream-app</code></li>
      <li>
        To run the generated React app: <code>npm start</code><br>
        You should see the following in your default web browser:<br>
        <img alt="create-react-app first page"
          src="images/create-react-app.png">
      </li>
      <li>
        Following the instructions on that page, edit src/App.js.
        Change the line "Welcome to React" to "Welcome to Ice Cream".
      </li>
      <li>
        When changes are saved, the browser window will automatically
        refresh to show the results of the changes.
      </li>
    </ol>

    <h3>Ice Cream App UI</h3>
    <p>
      Our UI will consist of two pages.
      The first page is for user registration and login.
    </p>
    <img alt="Ice Cream App Login Page"
      src="images/ice-cream-login.png">

    <p>
      The second page is reached after successful user registration or login.
      It allows the user to add and delete ice cream flavors.
      Pressing the "Log out" button in the upper-right corner
      ends their session and returns them to the login page.
    </p>
    <img alt="Ice Cream App Flavors Page"
      src="images/ice-cream-flavors.png">

    <p>
      Going into the details of React is beyond the scope of this article.
      However, hopefully the code will be readable even for those
      without React exposure.  The code is heavily commented.
      If you are not particularly interested in learning about React,
      scan though the code to see where the REST calls are made
      and how the responses are handled.
    </p>

    <h4>public/index.html</h4>
    <p>
      This is a slightly modified version of the one generated by create-react-app:
    </p>
    <pre class="brush: js">
&lt;!doctype html>
&lt;html lang="en">
  &lt;head>
    &lt;meta name="viewport" content="width=device-width, initial-scale=1">

    &lt;!--
      Notice the use of %PUBLIC_URL% in the tag below.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.
    -->
    &lt;link rel="shortcut icon" href="%PUBLIC_URL%/favicon.ico">

    &lt;title>React App&lt;/title>

    &lt;!--
      This was added to allow the client to listen to
      socket.io events emitted from the server.  It is used to
      proactively terminate sessions when the session timeout expires.
    -->
    &lt;script src="https://localhost/socket.io/socket.io.js">&lt;/script>
  &lt;/head>
  &lt;body>
    &lt;!--
      This element is populated by React.
      See the reference to 'root' in src/index.js.
    -->
    &lt;div id="root">&lt;/div>
  &lt;/body>
&lt;/html>
</pre>

    <h4>src/index.js</h4>
    <p>
      This file was generated by create-react-app.
      It is the first JavaScript file that is loaded.
      The file <code>index.html</code> doesn't include a script tag for this.
      create-react-app causes this to be loaded.
      It is specified in
      <code>node_modules/react-scripts/config/paths.js</code>
      as <code>appIndexJs</code> and used in
      <code>webpack.config.*.js</code> in that same directory.
      Note that this file imports <code>App.js</code>.
    </p>
    <pre class="brush: js">
import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';
import './index.css';

// This creates an instance of the App component and renders it
// inside the div with an id of "root" in public/index.html.
ReactDOM.render(
  &lt;App/>,
  document.getElementById('root')
);
</pre>

    <h4>src/App.js</h4>
    <p>
      This is a heavily modified version of the one generated by create-react-app.
      See the comments for details.
    </p>
    <pre class="brush: js">
import React, {Component} from 'react';
import Login from './login';
import Main from './main';
import 'whatwg-fetch';
import './App.css';

class App extends Component {
  constructor() {
    super();

    // Redux is a popular library for managing state in a React application.
    // This application, being somewhat small, opts for a simpler approach
    // where the top-most component manages all of the state.
    // Placing a bound version of the setState method on the React object
    // allows other components to call it in order to modify state.
    // Each call causes the UI to re-render.
    React.setState = this.setState.bind(this);

    // This gets a socket.io connection from the server
    // and registers for "session-timeout" events.
    // If one is received, the users is logged out.
    /* global io */
    const socket = io('https://localhost', {secure: true});
    socket.on('session-timeout', () => {
      alert('Your session timed out.');
      this.logout();
    });
  }

  // This is the initial state of the application.
  state = {
    authenticated: false,
    error: '',
    flavor: '',
    iceCreamMap: {},
    password: '',
    restUrl: 'https://localhost',
    route: 'login', // controls the current page
    token: '',
    username: ''
  };

  /**
   * Sends a logout POST request to the server
   * and goes to the login page.
   */
  logout = () => {
    /* eslint-disable no-invalid-this */
    const url = `${this.state.restUrl}/logout`;
    const headers = {Authorization: this.state.token};
    fetch(url, {method: 'POST', headers})
      .then(() => React.setState({
        authenticated: false,
        route: 'login',
        password: '',
        username: ''
      }))
      .catch();
  };

  render() {
    // Use destructuring to extract data from the state object.
    const {
      authenticated, error, flavor, iceCreamMap,
      password, restUrl, route, token, username
    } = this.state;

    return (
      &lt;div className="App">
        &lt;header>
          &lt;img className="header-img" src="ice-cream.png" alt="ice cream"/>
          Ice cream, we all scream for it!
          {
            authenticated ?
              &lt;button onClick={this.logout}>Log out&lt;/button> :
              null
          }
        &lt;/header>
        &lt;div className="App-body">
          {
            // This is an alternative to controlling routing to pages
            // that is far simpler than more full-blown solutions
            // like react-router.
            route === 'login' ?
              &lt;Login
                username={username}
                password={password}
                restUrl={restUrl}
              /> :
            route === 'main' ?
              &lt;Main
                flavor={flavor}
                iceCreamMap={iceCreamMap}
                restUrl={restUrl}
                token={token}
                username={username}
              /> :
              &lt;div>Unknown route {route}&lt;/div>
          }
          {
            // If an error has occurred, render it at the bottom of any page.
            error ? &lt;div className="error">{error}&lt;/div> : null
          }
        &lt;/div>
      &lt;/div>
    );
  }
}

export default App;</pre>

    <h4>src/App.css</h4>
    <p>
      All the CSS for this app resides here,
      with the exception of <code>src/index.css</code> which is
      generated by create-react-app and doesn't require modification..
      It is outside of the scope of this article to cover CSS,
      but the source can be found in the
      <a href="https://github.com/mvolkmann/ice-cream-app/blob/master/src/App.css" target="_blank">Github repo</a>.
    </p>

    <h4>src/login.js</h4>
    <p>
      This component allows new users to signup and
      existing users to log in.
    </p>
    <pre class="brush: js">
import React, {Component} from 'react';
import 'whatwg-fetch'; // sends HTTP requests

const {string} = React.PropTypes;

function onChangePassword(event) {
  React.setState({password: event.target.value});
}

function onChangeUsername(event) {
  React.setState({username: event.target.value});
}

/* eslint-disable no-invalid-this */
class Login extends Component {

  static propTypes = {
    password: string.isRequired,
    restUrl: string.isRequired,
    username: string.isRequired
  };

  // This is called when the "Log In" button is pressed.
  onLogin = () => {
    const {password, restUrl, username} = this.props;
    let token;
    const url = `${restUrl}/login`;

    // Send username and password to login REST service.
    fetch(url, {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({username, password})
    })
      .then(res => {
        token = res.headers.get('Authorization');
        return res.text(); // returns a promise
      })
      .then(text => {
        const authenticated = text === 'true';
        React.setState(authenticated ?
          {
            authenticated: true,
            error: null, // clear previous error
            route: 'main',
            token
          } :
          {
            error: 'Invalid username or password.'
          });
      })
      .catch(res => {
        React.setState({error: `${url}; ${res.message}`});
      });
  }

  // This is called when the "Signup" button is pressed.
  onSignup = () => {
    const {password, restUrl, username} = this.props;
    let token;
    const url = `${restUrl}/signup`;
    let error = false;

    fetch(url, {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({username, password})
    })
      .then(res => {
        token = res.headers.get('Authorization');
        if (!res.ok) error = true;
        return res.text(); // returns a promise
      })
      .then(text => {
        if (error) {
          if (/duplicate key/.test(text)) {
            text = `User ${username} already exists.`;
          }
          React.setState({error: text});
        } else { // successful signup
          React.setState({
            authenticated: true,
            error: null,
            route: 'main',
            token, username
          });
        }
      })
      .catch(res => {
        React.setState({error: `${url}; ${res.message}`});
      });
  }

  render() {
    const {password, username} = this.props;
    const canSubmit = username &amp;&amp; password;

    // We are handling sending the username and password
    // to a REST service above, so we don't want
    // the HTML form to submit anything for us.
    // That is the reason for the call to preventDefault.
    return (
      &lt;form className="login-form"
        onSubmit={event => event.preventDefault()}>
        &lt;div className="row">
          &lt;label>Username:&lt;/label>
          &lt;input type="text"
            autoFocus
            onChange={onChangeUsername}
            value={username}
          />
        &lt;/div>
        &lt;div className="row">
          &lt;label>Password:&lt;/label>
          &lt;input type="password"
            onChange={onChangePassword}
            value={password}
          />
        &lt;/div>
        &lt;div className="row submit">
          {/* Pressing enter in either input invokes the first button. */}
          &lt;button disabled={!canSubmit} onClick={this.onLogin}>
            Log In
          &lt;/button>
          &lt;button disabled={!canSubmit}onClick={this.onSignup}>
            Signup
          &lt;/button>
        &lt;/div>
      &lt;/form>
    );
  }
}

export default Login;</pre>

    <h4>src/main.js</h4>
    <p>
      This is the main page of the app where users can
      view the ice cream flavors they like,
      enter new ones, and delete existing ones.
    </p>
    <pre class="brush: js">
import IceCreamEntry from './ice-cream-entry';
import IceCreamList from './ice-cream-list';
import React, {Component} from 'react';
import 'whatwg-fetch';

const {object, string} = React.PropTypes;

function changeFlavor(event) {
  React.setState({flavor: event.target.value});
}

function handleError(url, res) {
  React.setState(res.status === 440 ?
    {error: 'Session Timeout', route: 'login'} :
    {error: res.message});
}

class Main extends Component {

  static propTypes = {
    flavor: string.isRequired,
    // eslint-disable-next-line react/forbid-prop-types
    iceCreamMap: object.isRequired,
    restUrl: string.isRequired,
    token: string.isRequired,
    username: string.isRequired
  };

  /**
   * Gets the current list of ice cream flavors
   * liked by the current user.
   */
  componentDidMount() {
    const {restUrl, token, username} = this.props;

    // This header is used in all REST calls.
    this.headers = {Authorization: token};

    const url = `${restUrl}/ice-cream/${username}`;
    fetch(url, {headers: this.headers})
      .then(res => {
        if (!res.ok) handleError(url, res);
        return res.ok ? res.json() : null;
      })
      .then(iceCreams => {
        const iceCreamMap = {};
        for (const iceCream of iceCreams) {
          iceCreamMap[iceCream.id] = iceCream.flavor;
        }
        React.setState({iceCreamMap});
      })
      .catch(handleError.bind(null, url));
  }

  /* eslint-disable no-invalid-this */

  /**
   * Adds an ice cream flavor to the list
   * of those liked by the current user.
   */
  addIceCream = flavor => {
    const {restUrl, username} = this.props;
    const url = `${restUrl}/ice-cream/${username}?flavor=${flavor}`;
    fetch(url, {method: 'POST', headers: this.headers})
      .then(res => {
        if (!res.ok) handleError(url, res);
        return res.ok ? res.text() : null;
      })
      .then(id => {
        if (!id) return;

        // Now that it has been successfully added to the database,
        // add it in the UI.
        id = Number(id);
        const {iceCreamMap} = this.props;
        iceCreamMap[id] = flavor;
        React.setState({flavor: '', iceCreamMap});
      })
      .catch(handleError.bind(null, url));
  };

  /**
   * Deletes an ice cream flavor from the list
   * of those liked by the current user.
   */
  deleteIceCream = id => {
    const {restUrl, username} = this.props;
    const url = `${restUrl}/ice-cream/${username}/${id}`;
    fetch(url, {method: 'DELETE', headers: this.headers})
      .then(res => {
        if (res.ok) {
          // Now that it has been successfully deleted from the database,
          // delete it from the UI.
          const {iceCreamMap} = this.props;
          delete iceCreamMap[id];
          React.setState({iceCreamMap});
        } else {
          handleError(url, res);
        }
      })
      .catch(handleError.bind(null, url));
  };

  render() {
    const {flavor, iceCreamMap, username} = this.props;
    return (
      &lt;div className="main">
        &lt;IceCreamEntry
          addCb={this.addIceCream}
          changeCb={changeFlavor}
          flavor={flavor}
        />
        &lt;label>{username}'s favorite flavors are:&lt;/label>
        &lt;IceCreamList
          deleteCb={this.deleteIceCream}
          iceCreamMap={iceCreamMap}
        />
      &lt;/div>
    );
  }
}

export default Main;</pre>

    <h4>src/ice-cream-entry.js</h4>
    <p>
      This component renders the components for
      entering, viewing, and deleting ice cream flavors.
    </p>
    <pre class="brush: js">
import React from 'react';

const IceCreamEntry = ({addCb, changeCb, flavor}) =>
  &lt;form
    className="ice-cream-entry"
    onSubmit={event => event.preventDefault()}
  >
    &lt;label>Flavor&lt;/label>
    &lt;input type="text" autoFocus onChange={changeCb} value={flavor}/>
    {/* using unicode heavy plus for button */}
    &lt;button onClick={() => addCb(flavor)}>&#x2795;&lt;/button>
  &lt;/form>;

const {func, string} = React.PropTypes;
IceCreamEntry.propTypes = {
  addCb: func.isRequired,
  changeCb: func.isRequired,
  flavor: string.isRequired,
};

export default IceCreamEntry;</pre>

    <h4>src/ice-cream-list.js</h4>
    <p>
      This component renders a sorted list of the ice cream flavors
      that the user likes and allows them to be deleted.
    </p>
    <pre class="brush: js">
import React from 'react';
import IceCreamRow from './ice-cream-row';

const IceCreamList = ({deleteCb, iceCreamMap}) => {
  const list =
    Object.keys(iceCreamMap).map(
      id => ({id, flavor: iceCreamMap[id]}));
  list.sort(
    (a, b) => a.flavor.localeCompare(b.flavor));

  return (
    &lt;ul className="ice-cream-list">
      {
        list.map(iceCream =>
          &lt;IceCreamRow
            deleteCb={deleteCb}
            id={iceCream.id}
            key={iceCream.id}
            flavor={iceCream.flavor}
          />)
      }
    &lt;/ul>
  );
};

const {func, object} = React.PropTypes;
IceCreamList.propTypes = {
  deleteCb: func.isRequired,
  // eslint-disable-next-line react/forbid-prop-types
  iceCreamMap: object.isRequired
};

export default IceCreamList;</pre>

    <h4>src/ice-cream-row.js</h4>
    <p>
      This component renders a single ice cream flavor
      that the user likes and allows it to be deleted.
    </p>
    <pre class="brush: js">
import React from 'react';

const IceCreamRow = ({deleteCb, flavor, id}) =>
  &lt;li className="ice-cream-row">
    {/* using unicode heavy x for button */}
    &lt;button onClick={() => deleteCb(id)}>&#x2716;&lt;/button>
    {flavor}
  &lt;/li>;

const {func, string} = React.PropTypes;
IceCreamRow.propTypes = {
  deleteCb: func.isRequired,
  flavor: string,
  id: string
};

export default IceCreamRow;</pre>

    <h3><a name="nodemon">nodemon</a></h3>
    <p>
      When iteratively making changes to REST service code,
      it is convenient the have the REST server automatically restart
      when changes are saved.
      The npm package
      <a href="https://github.com/remy/nodemon" target="_blank">nodemon</a>
      monitors files in and below the current directory for changes.
      When a change is detected, it restarts running of a specified JavaScript file.
    </p>
    <p>
      To install it, enter: <code>npm install --save-dev nodemon</code><br>
      To run it, enter: <code>nodemon {file-path}</code>.
    </p>

    <h3>SSL Certificates</h3>
    <p>
      To view and delete certificates from Chrome,
      select "Chrome ... Preferences...", select "Settings",
      scroll to bottom, click "Show advanced settings...",
      scroll to "HTTPS/SSL", press the "Manage certificates..." button.
      On a Mac this opens the "Keychain Access" application
      which is in Applications/Utilities.
    </p>

    <h3>Wrap the application in a Docker container</h3>
    <p>
    </p>

    <h3>Deploy the application somewhere</h3>
    <p>
    </p>

    <h3>Summary</h3>
    <p>
    </p>
  </body>
</html>
